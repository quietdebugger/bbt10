"""
Signal Backtester Plugin (Quant Lab)
Simple vector backtester for technical signals.
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from typing import Dict, Any
import logging

from architecture_modular import AnalysisPlugin, AnalysisResult, register_plugin

logger = logging.getLogger(__name__)

@register_plugin
class BacktesterPlugin(AnalysisPlugin):
    """
    Vector Backtester for Technical Rules
    """
    
    @property
    def name(self) -> str:
        return "Quant Lab"
    
    @property
    def icon(self) -> str:
        return "ðŸ§ª"
    
    @property
    def description(self) -> str:
        return "Test simple technical strategies on historical data."
    
    @property
    def category(self) -> str:
        return "ai"
    
    @property
    def enabled_by_default(self) -> bool:
        return True
    
    def analyze(self, context: Dict[str, Any]) -> AnalysisResult:
        # This plugin is interactive, analysis happens on user trigger in render
        # But we prepare the data here
        price_data = context.get('price_data')
        if price_data is None or price_data.empty:
            return AnalysisResult(success=False, data={}, error="Price data unavailable")
            
        return AnalysisResult(success=True, data={'price_data': price_data})

    def run_backtest(self, df: pd.DataFrame, entry_rule: str, exit_rule: str) -> Dict:
        """
        Run a simple vector backtest
        """
        # Prepare Indicators
        data = df.copy()
        data['SMA_20'] = data['close'].rolling(20).mean()
        data['SMA_50'] = data['close'].rolling(50).mean()
        data['SMA_200'] = data['close'].rolling(200).mean()
        
        # RSI
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
        rs = gain / loss
        data['RSI'] = 100 - (100 / (1 + rs))
        
        # Logic Evaluation
        # We'll use simple string parsing for safety (restricted scope)
        # Allowed tokens: close, open, high, low, volume, SMA_20, SMA_50, SMA_200, RSI, >, <, >=, <=, ==, and, or
        
        def evaluate_condition(condition_str, df):
            try:
                # Map friendly names to df columns
                token_map = {
                    'Price': 'df["close"]',
                    'SMA20': 'df["SMA_20"]',
                    'SMA50': 'df["SMA_50"]',
                    'SMA200': 'df["SMA_200"]',
                    'RSI': 'df["RSI"]',
                    'Volume': 'df["volume"]'
                }
                
                eval_str = condition_str
                for key, val in token_map.items():
                    eval_str = eval_str.replace(key, val)
                
                # Safe eval? Using pandas eval is better but strictly we'd parse.
                # For this prototype, we'll assume valid pandas syntax generated by UI
                return pd.eval(eval_str)
            except Exception as e:
                logger.error(f"Backtest rule error: {e}")
                return pd.Series([False]*len(df), index=df.index)

        # Generate Signals
        # 1 = Long, 0 = Cash
        data['signal'] = 0
        
        if entry_rule == "Golden Cross (SMA20 > SMA50)":
            data.loc[data['SMA_20'] > data['SMA_50'], 'signal'] = 1
        elif entry_rule == "Price > SMA200":
            data.loc[data['close'] > data['SMA_200'], 'signal'] = 1
        elif entry_rule == "RSI Oversold (<30)":
            data.loc[data['RSI'] < 30, 'signal'] = 1
        
        # Calculate Returns
        # Shift signal by 1 because we enter at Close of Signal Day (or Open of next)
        # Here assuming entering on Close of signal day (vector approximation)
        data['strategy_returns'] = data['close'].pct_change() * data['signal'].shift(1)
        data['buy_hold_returns'] = data['close'].pct_change()
        
        # Equity Curve
        data['strategy_equity'] = (1 + data['strategy_returns']).cumprod()
        data['buy_hold_equity'] = (1 + data['buy_hold_returns']).cumprod()
        
        # Metrics
        total_return = (data['strategy_equity'].iloc[-1] - 1) * 100
        bh_return = (data['buy_hold_equity'].iloc[-1] - 1) * 100
        win_rate = len(data[data['strategy_returns'] > 0]) / len(data[data['strategy_returns'] != 0]) * 100 if len(data[data['strategy_returns'] != 0]) > 0 else 0
        
        return {
            'equity_curve': data[['strategy_equity', 'buy_hold_equity']],
            'metrics': {
                'Total Return': total_return,
                'Buy & Hold': bh_return,
                'Win Rate': win_rate
            }
        }

    def render(self, result: AnalysisResult):
        st.subheader(f"{self.icon} {self.name}")
        
        if not result.success:
            st.error(f"Backtester error: {result.error}")
            return
            
        price_data = result.data['price_data']
        
        # Configuration
        c1, c2, c3 = st.columns([2, 2, 1])
        
        with c1:
            strategy = st.selectbox(
                "Select Strategy",
                ["Golden Cross (SMA20 > SMA50)", "Price > SMA200", "RSI Oversold (<30)"]
            )
        
        with c3:
            run = st.button("Run Test")
            
        if run:
            res = self.run_backtest(price_data, strategy, "")
            metrics = res['metrics']
            curve = res['equity_curve']
            
            # Metrics Row
            m1, m2, m3 = st.columns(3)
            m1.metric("Strategy Return", f"{metrics['Total Return']:.2f}%", 
                     delta=f"{metrics['Total Return'] - metrics['Buy & Hold']:.2f}% vs B&H")
            m2.metric("Buy & Hold", f"{metrics['Buy & Hold']:.2f}%")
            m3.metric("Win Rate", f"{metrics['Win Rate']:.1f}%")
            
            # Chart
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=curve.index, y=curve['strategy_equity'], name='Strategy', line=dict(color='#00FFA3')))
            fig.add_trace(go.Scatter(x=curve.index, y=curve['buy_hold_equity'], name='Buy & Hold', line=dict(color='gray', dash='dash')))
            
            fig.update_layout(
                title="Equity Curve",
                height=350,
                margin=dict(t=30, b=10, l=10, r=10),
                paper_bgcolor='rgba(0,0,0,0)',
                plot_bgcolor='rgba(0,0,0,0)'
            )
            st.plotly_chart(fig, use_container_width=True)
